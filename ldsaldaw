--[[
    Script: Arena Auto Farm for [Game Name]
    UI Library: Rayfield
    Feature: Auto-Farm with robust gate opening detection (Transparency/AncestryChanged)
--]]

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- ** 1. UI Setup **
local Window = Rayfield:CreateWindow({
    Name = "Rayfield Example Window",
    Icon = 0, 
    LoadingTitle = "Rayfield Interface Suite",
    LoadingSubtitle = "by Sirius",
    ShowText = "Rayfield", 
    Theme = "Default",
    ToggleUIKeybind = "K", 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, 
    ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, 
      FileName = "Big Hub"
    },
    Discord = { Enabled = false, Invite = "noinvitelink", RememberJoins = true },
    KeySystem = false, 
    KeySettings = { Title = "Untitled", Subtitle = "Key System", Note = "No method of obtaining the key is provided", FileName = "Key", SaveKey = true, GrabKeyFromSite = false, Key = {"Hello"} }
})

-- ** 2. Core Variables & Services Setup **
local isAutoFarmActive = false
local autoFarmThread = nil

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer 

-- ** 3. Auto-Farm Function (The Engine) **
local function runAutoFarm()
    
    -- --- Initial Service/Object Loading (Robust with Timeout) ---
    local function loadResources()
        -- Fetch services with robust checks
        local Knit = ReplicatedStorage:WaitForChild("Packages", 30):FindFirstChild("Knit")
        if not Knit then warn("Knit Package not found.") return end
        
        local Services = Knit:FindFirstChild("Services")
        if not Services then warn("Services Folder not found.") return end
        
        local MonsterService = Services:WaitForChild("MonsterService", 30)
        if not MonsterService then warn("MonsterService not found.") return end

        local RF_Folder = MonsterService:WaitForChild("RF", 30)
        if not RF_Folder then warn("RF Folder not found.") return end

        local CanAttackRF = RF_Folder:WaitForChild("CanAttack", 30)
        local RequestAttackRF = RF_Folder:WaitForChild("RequestAttack", 30)

        if not CanAttackRF or not RequestAttackRF then warn("Remote Functions not found.") return end

        local arenaModel = Workspace:WaitForChild("The Grand Arena", 60)
        local roomsFolder = arenaModel:WaitForChild("Rooms", 30)
        local room1 = roomsFolder:WaitForChild("1", 30) 

        return CanAttackRF, RequestAttackRF, roomsFolder, room1
    end

    local CanAttackRF, RequestAttackRF, roomsFolder, room1 = loadResources()
    
    if not roomsFolder then 
        print("Required game objects failed to load. Stopping Auto-Farm.")
        return 
    end
    
    -- --- Barrier Detection Helper ---
    local function findYellowBarrier()
        local doorModel = room1:FindFirstChild("Door")
        if doorModel then
            for _, obj in pairs(doorModel:GetDescendants()) do
                if obj:IsA("BasePart") and (obj.Name == "Part" or obj.Name == "Wall") and obj.Transparency < 1 then
                    return obj 
                end
            end
        end
        return nil
    end

    -- --- Wait for Game Start Logic ---
    local function waitForGameStart()
        print("Waiting for the current round barrier to disappear...")
        local currentBarrier = findYellowBarrier()
        local waitCount = 0

        while currentBarrier and waitCount < 30 do 
            print("Door is still present. Waiting for it to be removed or destroyed...")
            
            -- Use pcall/AncestryChanged to wait reliably for the Part to be removed
            local success, err = pcall(function()
                currentBarrier.AncestryChanged:Wait()
            end)
            
            if success then
                print("Barrier detected as removed/destroyed.")
                wait(0.5) 
                return
            end
            
            wait(1)
            waitCount = waitCount + 1
            currentBarrier = findYellowBarrier() 
        end
        
        if waitCount >= 30 then
            print("Timeout waiting for barrier. Using 7s countdown fallback.")
            wait(7)
        end
        
        print("Round Start Confirmed.")
    end 
    
    -- --- Main Loop Start ---
    print("Auto-Farm Thread started. Initializing...")
    waitForGameStart()

    while isAutoFarmActive do 
        wait(1) 
        
        if not isAutoFarmActive then break end 

        local playerCharacter = LocalPlayer.Character
        local playerRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

        if not playerRootPart then continue end
        
        local closestMonster = nil
        local minDistance = math.huge

        -- Find closest monster logic
        for i, room in pairs(roomsFolder:GetChildren()) do
            local enemiesFolder = room:FindFirstChild("Enemies")
            if enemiesFolder then
                for j, monster in pairs(enemiesFolder:GetChildren()) do
                    local humanoid = monster:FindFirstChildOfClass("Humanoid")
                    local monsterRootPart = monster:FindFirstChild("HumanoidRootPart")
                    
                    if humanoid and humanoid.Health > 0 and monsterRootPart then
                        local distance = (playerRootPart.Position - monsterRootPart.Position).Magnitude
                        
                        if distance < minDistance then
                            minDistance = distance
                            closestMonster = monster
                        end
                    end
                end
            end
        end

        if closestMonster then
            
            -- Pre-teleport check for stuck door
            if findYellowBarrier() then
                 print("Monster found, but door is still present! Waiting for round start...")
                 waitForGameStart() 
                 continue
            end
            
            -- Teleport and Attack
            local targetRootPart = closestMonster:FindFirstChild("HumanoidRootPart")
            if targetRootPart then
                playerRootPart.CFrame = targetRootPart.CFrame * CFrame.new(0, 5, 0)
                wait(0.1)

                local argsCanAttack = { LocalPlayer }
                local canActuallyAttack = CanAttackRF:InvokeServer(unpack(argsCanAttack))
                
                if canActuallyAttack then
                    local argsRequestAttack = { targetRootPart.CFrame }
                    RequestAttackRF:InvokeServer(unpack(argsRequestAttack))
                    wait(0.8) 
                else
                    print("CanAttack = false (Cooldown?)")
                end
            end
        else
            print("No living monsters found. Waiting for next round...")
            wait(5) 
            waitForGameStart() 
            wait(2)
        end
    end
    print("Auto-Farm stopped.")
end

-- ** 4. Rayfield Toggle Integration **
local ArenaTab = Window:CreateTab("Arena", "Arena")
local FarmSection = ArenaTab:CreateSection("Auto Farming")

FarmSection:CreateToggle({
    Name = "Auto Farm Arena",
    CurrentValue = false,
    Flag = "AutoFarmToggle",
    Callback = function(newState)
        if newState == true then
            isAutoFarmActive = true
            print("Auto-Farm Toggle ON. Starting script...")
            
            -- Use spawn to run the farm loop in a separate thread
            autoFarmThread = spawn(runAutoFarm)
            
        else
            isAutoFarmActive = false
            print("Auto-Farm Toggle OFF. Stopping script...")
        end
    end,
})
